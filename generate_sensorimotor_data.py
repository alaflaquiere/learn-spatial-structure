import numpy as np
import os
import sys
import shutil
import Agents
import Environments
import _pickle as cpickle
from argparse import ArgumentParser
import uuid

# TODO: clean the dependencies (after removing flatland)

# TODO: save an image of the environment with the data
# todo: check what is missing in the local/venv pyrender


def check_savability(destination, dictionary):
    """sanity check: try dumping a file on the disk and check it is not too large"""
    temp_name = "/".join([destination, "temp_dump.todelete"])
    try:
        with open(temp_name, 'wb') as f:
            cpickle.dump(dictionary, f)
    except OverflowError:
        return False
    finally:
        os.remove(temp_name)
    return True


def save_dictionary(destination, dictionary, filename):
    """pickle a dictionary and save it to the disk"""

    temp_name = "/".join([destination, filename])

    # if the filename already exists
    while os.path.exists(temp_name):
        temp_name += "_bis"

    # try saving the data
    try:
        with open(temp_name, 'wb') as f:
            cpickle.dump(dictionary, f)
    except:
        print("ERROR: saving the data to disk failed")
        return False

    # try reloading the data to ensure it was correctly saved
    try:
        with open(temp_name, 'rb') as f:
            cpickle.load(f)
    except:
        print("ERROR: saving the data to disk failed (impossible to reload it")
        return False

    return True


def create_directory(directory, safe=True):
    """Create the directory or ask permission to overwrite it if it already exists"""
    if os.path.exists(directory) and safe:
        ans = input("> WARNING: The folder {} already exists; do you want to overwrite its content? [y,n]: ".format(directory))
        if ans in ["y", "Y", "yes", "Yes", "YES"]:
            shutil.rmtree(directory)
        else:
            print("exiting the program")
            sys.exit()
    os.makedirs(directory)
    return True


def generate_sensorimotor_data(agent, environment, explo_type, k, dest_data="dataset", disp=True):
    """
    Generates a sensorimotor dataset and save it in <dest_data>/dataset_<explo_type>.pkl.
    k sensorimotor transitions are generated by drawing random motor configurations and environment shifts for each sensorimotor experience.

    Inputs:
        agent : the agent generating the motor configurations and egocentric sensor positions
        environment - the environment generating the environment shifts and the sensations associated with the holistic sensor positions
        explo_type - type of exploration, which changes how the shifts are generated
                     MM: the shift is always 0
                     MEM: a different shift is drawn for the first and second sensorimotor couple of each transition
                     MME: the same random shift is used for both sensorimotor pairs of each transition
        k - number of transitions to generate
        dest_data - directory where to save the data
        disp - display the data generated data

    Output:
        The generated dataset is saved in <dest_data>/dataset_<explo_type>.pkl as a dictionary with the following structure:
        transitions = {"motor_t": np.array(n_transitions, agent.n_motors),
                       "sensor_t": np.array(n_transitions, environment.n_sensations),
                       "shift_t": np.array(n_transitions, 2)2,
                       "motor_tp": np.array(n_transitions, agent.n_motors),
                       "sensor_tp": np.array(n_transitions, environment.n_sensations),
                       "shift_tp": np.array(n_transitions, 2),
                       "grid_motor": np.array(agent.size_regular_grid, agent.n_motors),
                       "grid_pos": np.array(agent.size_regular_grid, 2)
                       }
    """

    print("generating {} data... ".format(explo_type))

    # prepare the data dictionary
    transitions = {"motor_t": np.full((k, agent.n_motors), np.nan),
                   "sensor_t": np.full((k, environment.n_sensations), np.nan),
                   "shift_t": np.full((k, 2), np.nan),
                   "motor_tp": np.full((k, agent.n_motors), np.nan),
                   "sensor_tp": np.full((k, environment.n_sensations), np.nan),
                   "shift_tp": np.full((k, 2), np.nan),
                   "grid_motor": np.full((agent.size_regular_grid, agent.n_motors), np.nan),
                   "grid_pos": np.full((agent.size_regular_grid, 2), np.nan)}

    if check_savability(dest_data, transitions) is False:
        print("ERROR: the dataset is too large to pickle - reduce the number of transitions, sensations, or motors")
        return 1

    # generate random transitions
    filled = 0
    while filled < k:

        # generate (k - filled) motor states and sensor positions
        motor_t, ego_pos_t = agent.generate_random_sampling(k - filled)
        motor_tp, ego_pos_tp = agent.generate_random_sampling(k - filled)

        # generate (k - filled) shifts of the environment
        if explo_type is 'MEM':
            shifts_t = environment.generate_shift(k - filled)
            shifts_tp = environment.generate_shift(k - filled)
        elif explo_type is 'MM':
            shifts_t = environment.generate_shift(k - filled, static=True)  # use environment.generate_shift to get the correct data type
            shifts_tp = shifts_t
        elif explo_type is 'MME':
            shifts_t = environment.generate_shift(k - filled)
            shifts_tp = shifts_t
        else:
            print("ERROR: wrong type of exploration - use 'MM', 'MEM', or 'MME'")
            return 1

        # compute the holistic position of the sensor
        holi_pos_t = ego_pos_t + shifts_t
        holi_pos_tp = ego_pos_tp + shifts_tp

        # get the corresponding sensations
        sensations_t = environment.get_sensation_at_position(holi_pos_t, display=disp)
        sensations_tp = environment.get_sensation_at_position(holi_pos_tp, display=disp)

        # get the indexes of valid sensory inputs
        valid_indexes = np.argwhere((~np.isnan(sensations_t[:, 0])) & (~np.isnan(sensations_tp[:, 0])))[:, 0]

        # fill the dictionary
        transitions["motor_t"][filled:filled + len(valid_indexes), :] = motor_t[valid_indexes, :]
        transitions["sensor_t"][filled:filled + len(valid_indexes), :] = sensations_t[valid_indexes, :]
        transitions["shift_t"][filled:filled + len(valid_indexes), :] = shifts_t[valid_indexes, :]
        transitions["motor_tp"][filled:filled + len(valid_indexes), :] = motor_tp[valid_indexes, :]
        transitions["sensor_tp"][filled:filled + len(valid_indexes), :] = sensations_tp[valid_indexes, :]
        transitions["shift_tp"][filled:filled + len(valid_indexes), :] = shifts_tp[valid_indexes, :]

        # update filled
        filled = filled + len(valid_indexes)

    # generate a regular grid of motor configurations and sensor egocentric positions for evaluation
    transitions["grid_motor"], transitions["grid_pos"] = agent.generate_regular_sampling()

    save_dictionary(dest_data, transitions, "dataset_{}.pkl".format(explo_type))


def save_agent_and_environment(directory, agent, environment):
    """save the agent and environment to disk"""

    # save the agent and environment parameters in a readable form
    agent.log(directory + "/agent_params.txt")
    environment.log(directory + "/environment_params.txt")

    # save agent to disk
    try:
        with open(directory + "/agent.pkl", "wb") as f:
            cpickle.dump(agent, f)
    except:
        print("ERROR: saving the agent in {} failed".format(directory))
        return False

    # save environment to disk
    try:
        with open(directory + "/environment.pkl", "wb") as f:
            cpickle.dump(environment, f)
    except:
        print("ERROR: saving the environment in {} failed".format(directory))
        return False

    # create and save a unique identifier for the dataset
    try:
        with open(directory + "/uuid.txt", "w") as f:
            f.write(uuid.uuid4().hex)
    except:
        print("ERROR: saving the UUID in {} failed".format(directory))
        return False

    return True


if __name__ == "__main__":

    # parser
    parser = ArgumentParser()
    parser.add_argument("-n", "--n_transitions", dest="n_transitions", help="number of transitions", type=int, default=150000)
    parser.add_argument("-t", "--type", dest="type_simu", help="type of simulation",
                        choices=["gridexplorer", "manydofgridexplorer", "arm3droom", "manydofarm3droom"], required=True)
    parser.add_argument("-r", "--n_runs", dest="n_runs", help="number of independent datasets generated", type=int, default=1)
    parser.add_argument("-d", "--dir_data", dest="dir_data", help="directory where to save the data", required=True)
    parser.add_argument("-v", "--visual", dest="display_exploration", help="flag to turn the online display on or off", action="store_true")
    #
    args = parser.parse_args()
    n_transitions = args.n_transitions
    type_simu = args.type_simu
    n_runs = args.n_runs
    dir_data = args.dir_data
    display_exploration = args.display_exploration

    # create the data directory
    create_directory(dir_data)

    # iterate over the runs
    for trial in range(n_runs):

        # subdirectory for the trial
        dir_data_trial = "/".join([dir_data, "dataset" + str(trial)])

        print("[ENVIRONMENT {} >> data saved in {}]".format(trial, dir_data_trial))

        # create the trial subdirectory
        create_directory(dir_data_trial, safe=False)

        # create the agent and environment according to the type of exploration
        if type_simu == "gridexplorer":
            my_agent = Agents.GridExplorer()
            my_environment = Environments.GridWorld()
        #
        elif type_simu == "manydofgridexplorer":
            my_agent = Agents.ManyDofGridExplorer()
            my_environment = Environments.GridWorld()
        #
        elif type_simu == "arm3droom":
            my_agent = Agents.HingeArm(segments_length=[0.5, 0.5, 0.5])  # working space of radius 1.5 in an environment of size size 7
            my_environment = Environments.GQNRoom()
        #
        elif type_simu == "manydofarm3droom":
            my_agent = Agents.ManyDofHingeArm(segments_length=[0.375, 0.375, 0.375, 0.375])  # working space of radius 1.5 in an environment of size size 7
            my_environment = Environments.GQNRoom()
        #
        else:
            print("ERROR: invalid type of simulation - use 'gridexplorer', 'manydofgridexplorer', 'arm3droom', or 'manydofarm3droom'")
            sys.exit()

        save_agent_and_environment(dir_data_trial, my_agent, my_environment)

        # run the three types of exploration: MEM, MM, MME
        generate_sensorimotor_data(my_agent, my_environment, "MEM", n_transitions, dir_data_trial, disp=display_exploration)
        generate_sensorimotor_data(my_agent, my_environment, "MM",  n_transitions, dir_data_trial, disp=display_exploration)
        generate_sensorimotor_data(my_agent, my_environment, "MME", n_transitions, dir_data_trial, disp=display_exploration)

    input("Press any key to exit the program.")
